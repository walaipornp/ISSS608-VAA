---
title: "Hands-on Exercise 3"
author: "Walaiporn Pawitranon"
---

# Overview

In this chapter, R programming will be introduce for interactive data visualization and animated statistical graphics .

# 1. Programming Interactive Data Visualization with R

## 1.1 Getting Started

First, write a code chunk to check, install and launch the following R packages:

-   [**ggiraph**](https://davidgohel.github.io/ggiraph/) for making ‘ggplot’ graphics interactive.

-   [**plotly**](https://plotly.com/r/), R library for plotting interactive statistical graphs.

-   [**DT**](https://rstudio.github.io/DT/) provides an R interface to the JavaScript library [DataTables](https://datatables.net/) that create interactive table on html page.

-   [**tidyverse**](https://www.tidyverse.org/), a family of modern R packages specially designed to support data science, analysis and communication task including creating static statistical graphs.

-   [**patchwork**](https://patchwork.data-imaginist.com/) for combining multiple ggplot2 graphs into one figure.

The code chunk below will be used to accomplish the task.

```{r}
pacman::p_load(ggiraph, plotly, 
               patchwork, DT, tidyverse) 
```

## 1.2 Importing Data

In this section, the provided **Exam_data.csv** file will be used. Using **read_csv()** from the **readr** package, the data is imported into R.

The code chunk below demonstrates how **read_csv()** is used to load **Exam_data.csv** and store it as a tibble data frame named **exam_data**.

```{r}
exam_data <- read_csv("data/Exam_data.csv")
```

## 1.3 Interactive Data Visualization - ggiraph methods

**ggiraph** is an **htmlwidget** and a **ggplot2** extension that enables interactive ggplot graphics.

Interactivity is achieved through ggplot geometries that can recognize three key arguments:

-   **tooltip**: a column containing text to display when the mouse hovers over an element.

-   **onclick**: a column containing JavaScript functions to execute when an element is clicked.

-   **data_id**: a column containing unique IDs linked to elements.

When used within a **Shiny** application, elements associated with a **data_id** can be selected and manipulated on both the client and server sides. See this article for a more detailed explanation.

### 1.3.1 Tooltip effect with tooltip aesthetic

The following code chunk demonstrates how to create an interactive statistical plot using the **ggiraph** package. The code is divided into two main steps. First, a **ggplot** object is generated. Then, the **girafe()** function from **ggiraph** is applied to convert the plot into an interactive SVG graphic.

```{r}
p <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(
    aes(tooltip = ID),
    stackgroups = TRUE, 
    binwidth = 1, 
    method = "histodot") +
  scale_y_continuous(NULL, 
                     breaks = NULL)
girafe(
  ggobj = p,
  width_svg = 6,
  height_svg = 6*0.618
)
```

## 1.4 Interactivity

By hovering the mouse pointer on an data point of interest, the student’s ID will be displayed.

```{r}
p <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(
    aes(tooltip = ID),
    stackgroups = TRUE, 
    binwidth = 1, 
    method = "histodot") +
  scale_y_continuous(NULL, 
                     breaks = NULL)
girafe(
  ggobj = p,
  width_svg = 6,
  height_svg = 6*0.618
)
```

### 1.4.1 Displaying multiple information on tooltip

The content of the tooltip can be customized by including a list object as shown in the code chunk below.

```{r}
exam_data$tooltip <- c(paste0(     
  "Name = ", exam_data$ID,         
  "\n Class = ", exam_data$CLASS)) 

p <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(
    aes(tooltip = exam_data$tooltip), 
    stackgroups = TRUE,
    binwidth = 1,
    method = "histodot") +
  scale_y_continuous(NULL,               
                     breaks = NULL)
girafe(
  ggobj = p,
  width_svg = 8,
  height_svg = 8*0.618
)
```

The first three lines of codes in the code chunk create a new field called *tooltip*. At the same time, it populates text in ID and CLASS fields into the newly created field. Next, this newly created field is used as tooltip field as shown in the code of line 7.

### 1.4.2 Customizing Tooltip style

Code chunk below uses [`opts_tooltip()`](https://davidgohel.github.io/ggiraph/reference/opts_tooltip.html) of **ggiraph** to customize tooltip rendering by add css declarations.

```{r}
tooltip_css <- "background-color:white; #<<
font-style:bold; color:black;" #<<

p <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(              
    aes(tooltip = ID),                   
    stackgroups = TRUE,                  
    binwidth = 1,                        
    method = "histodot") +               
  scale_y_continuous(NULL,               
                     breaks = NULL)
girafe(                                  
  ggobj = p,                             
  width_svg = 6,                         
  height_svg = 6*0.618,
  options = list(    #<<
    opts_tooltip(    #<<
      css = tooltip_css)) #<<
)                                        
```

Notice that the background colour of the tooltip is black and the font colour is white and bold.

```{r}
tooltip_css <- "background-color:white; #<<
font-style:bold; color:black;" #<<

p <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(              
    aes(tooltip = ID),                   
    stackgroups = TRUE,                  
    binwidth = 1,                        
    method = "histodot") +               
  scale_y_continuous(NULL,               
                     breaks = NULL)
girafe(                                  
  ggobj = p,                             
  width_svg = 6,                         
  height_svg = 6*0.618,
  options = list(    #<<
    opts_tooltip(    #<<
      css = tooltip_css)) #<<
)                                        
```

### 1.4.3 Displaying statistics on tooltip

The code chunk below demonstrates an advanced method for customizing tooltips. In this example, a function is used to calculate the 90% confidence interval of the mean, and the resulting statistics are displayed within the tooltip.

```{r}
tooltip <- function(y, ymax, accuracy = .01) {
  mean <- scales::number(y, accuracy = accuracy)
  sem <- scales::number(ymax - y, accuracy = accuracy)
  paste("Mean maths scores:", mean, "+/-", sem)
}

gg_point <- ggplot(data=exam_data, 
                   aes(x = RACE),
) +
  stat_summary(aes(y = MATHS, 
                   tooltip = after_stat(  
                     tooltip(y, ymax))),  
    fun.data = "mean_se", 
    geom = GeomInteractiveCol,  
    fill = "light blue"
  ) +
  stat_summary(aes(y = MATHS),
    fun.data = mean_se,
    geom = "errorbar", width = 0.2, size = 0.2
  )

girafe(ggobj = gg_point,
       width_svg = 8,
       height_svg = 8*0.618)                                      
```

### 1.4.4 Hover effect with data_id aesthetic

Code chunk below shows the second interactive feature of ggiraph, namely `data_id`.

```{r}
p <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(           
    aes(data_id = CLASS),             
    stackgroups = TRUE,               
    binwidth = 1,                        
    method = "histodot") +               
  scale_y_continuous(NULL,               
                     breaks = NULL)
girafe(                                  
  ggobj = p,                             
  width_svg = 6,                         
  height_svg = 6*0.618                      
)                                                                            
```

Interactivity: Elements associated with a *data_id* (i.e CLASS) will be highlighted upon mouse over.

### 1.4.5 Styling hover effect

In the code chunk below, css codes are used to change the highlighting effect.

```{r}
p <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(              
    aes(data_id = CLASS),              
    stackgroups = TRUE,                  
    binwidth = 1,                        
    method = "histodot") +               
  scale_y_continuous(NULL,               
                     breaks = NULL)
girafe(                                  
  ggobj = p,                             
  width_svg = 6,                         
  height_svg = 6*0.618,
  options = list(                        
    opts_hover(css = "fill: #202020;"),  
    opts_hover_inv(css = "opacity:0.2;") 
  )                                        
)                                                                                                                 
```

Interactivity: Elements associated with a *data_id* (i.e CLASS) will be highlighted upon mouse over.

### 1.4.6 Combining tooltip and hover effect

There are time that we want to combine tooltip and hover effect on the interactive statistical graph as shown in the code chunk below.

```{r}
p <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(              
    aes(tooltip = CLASS, 
        data_id = CLASS),              
    stackgroups = TRUE,                  
    binwidth = 1,                        
    method = "histodot") +               
  scale_y_continuous(NULL,               
                     breaks = NULL)
girafe(                                  
  ggobj = p,                             
  width_svg = 6,                         
  height_svg = 6*0.618,
  options = list(                        
    opts_hover(css = "fill: #202020;"),  
    opts_hover_inv(css = "opacity:0.2;") 
  )                                        
)                                                                                                                                                        
```

Interactivity: Elements associated with a *data_id* (i.e CLASS) will be highlighted upon mouse over. At the same time, the tooltip will show the CLASS.

### 1.4.7 Click effect with onclick

onclick argument of ggiraph provides hotlink interactivity on the web. The code chunk below shown an example of onclick.

```{r}
exam_data$onclick <- sprintf("window.open(\"%s%s\")",
"https://www.moe.gov.sg/schoolfinder?journey=Primary%20school",
as.character(exam_data$ID))

p <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(              
    aes(onclick = onclick),              
    stackgroups = TRUE,                  
    binwidth = 1,                        
    method = "histodot") +               
  scale_y_continuous(NULL,               
                     breaks = NULL)
girafe(                                  
  ggobj = p,                             
  width_svg = 6,                         
  height_svg = 6*0.618)                                                                                                                                                                                    
```

Interactivity: Web document link with a data object will be displayed on the web browser upon mouse click.

### 1.4.8 Coordinated Multiple Views with ggiraph

Coordinated multiple views methods has been implemented in the data visualisation below.

Observe that when a data point in one of the dot plots is selected, the corresponding data point with the same ID in the second visualization is highlighted as well.

To construct the coordinated multiple views shown in the example above, the following programming approach is applied:

-   Relevant interactive functions from the **ggiraph** package are used to create multiple linked views.

-   The **patchwork()** function from the **patchwork** package is embedded within the **girafe()** function to produce interactive, coordinated visualizations.

```{r}
p1 <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(              
    aes(data_id = ID),              
    stackgroups = TRUE,                  
    binwidth = 1,                        
    method = "histodot") +  
  coord_cartesian(xlim=c(0,100)) + 
  scale_y_continuous(NULL,               
                     breaks = NULL)

p2 <- ggplot(data=exam_data, 
       aes(x = ENGLISH)) +
  geom_dotplot_interactive(              
    aes(data_id = ID),              
    stackgroups = TRUE,                  
    binwidth = 1,                        
    method = "histodot") + 
  coord_cartesian(xlim=c(0,100)) + 
  scale_y_continuous(NULL,               
                     breaks = NULL)

girafe(code = print(p1 + p2), 
       width_svg = 6,
       height_svg = 3,
       options = list(
         opts_hover(css = "fill: #202020;"),
         opts_hover_inv(css = "opacity:0.2;")
         )
       )                                                                                                                                                                                 
```

The *data_id* aesthetic is critical to link observations between plots and the tooltip aesthetic is optional but nice to have when mouse over a point.

## 1.5 Interactive Data Visualization - plotly methods!

Plotly’s R graphing library enables the creation of interactive web-based graphics from **ggplot2** plots and through a custom interface to the MIT-licensed JavaScript library **plotly.js**, which is inspired by the grammar of graphics. Unlike other Plotly platforms, plotly for R is free and open source.

There are two ways to create interactive graph by using plotly, they are:

-   by using *plot_ly()*, and

-   by using *ggplotly()*

### 1.5.1 Creating an interactive scatter plot: plot_ly() method

The tabset below shows an example a basic interactive plot created by using *plot_ly()*.

```{r}
plot_ly(data = exam_data, 
             x = ~MATHS, 
             y = ~ENGLISH)
```

### 1.5.2 Working with visual variable: plot_ly() method

In the code chunk below, *color* argument is mapped to a qualitative visual variable (i.e. RACE).

```{r}
plot_ly(data = exam_data, 
        x = ~ENGLISH, 
        y = ~MATHS, 
        color = ~RACE)
```

### 1.5.3 Creating an interactive scatter plot: ggplotly() method

The code chunk below plots an interactive scatter plot by using *ggplotly()*.

```{r}
p <- ggplot(data=exam_data, 
            aes(x = MATHS,
                y = ENGLISH)) +
  geom_point(size=1) +
  coord_cartesian(xlim=c(0,100),
                  ylim=c(0,100))
ggplotly(p)
```

### 1.5.4 Coordinated Multiple Views with plotly

Creating a coordinated linked plot using **plotly** involves three main steps:

1.  The **highlight_key()** function from the **plotly** package is used to define shared data.

2.  Two scatterplots are created using **ggplot2** functions.

3.  Finally, the **subplot()** function from the **plotly** package is used to arrange the plots side by side.

```{r}
d <- highlight_key(exam_data)
p1 <- ggplot(data=d, 
            aes(x = MATHS,
                y = ENGLISH)) +
  geom_point(size=1) +
  coord_cartesian(xlim=c(0,100),
                  ylim=c(0,100))

p2 <- ggplot(data=d, 
            aes(x = MATHS,
                y = SCIENCE)) +
  geom_point(size=1) +
  coord_cartesian(xlim=c(0,100),
                  ylim=c(0,100))
subplot(ggplotly(p1),
        ggplotly(p2))
```

## 1.6 Interactive Data Visualization - crosstalk methods!

Crosstalk is an extension of the htmlwidgets package. It enhances htmlwidgets by providing a set of classes, functions, and conventions to enable interactions between widgets, such as linked brushing and filtering.

### 1.6.1 Interactive Data Table: DT package

-   A wrapper of the JavaScript Library [DataTables](https://datatables.net/)

-   Data objects in R can be rendered as HTML tables using the JavaScript library ‘DataTables’ (typically via R Markdown or Shiny).

```{r}
DT::datatable(exam_data, class= "compact")
```

### 1.6.2 Linked brushing: crosstalk method

```{r}
d <- highlight_key(exam_data) 
p <- ggplot(d, 
            aes(ENGLISH, 
                MATHS)) + 
  geom_point(size=1) +
  coord_cartesian(xlim=c(0,100),
                  ylim=c(0,100))

gg <- highlight(ggplotly(p),        
                "plotly_selected")  

crosstalk::bscols(gg,               
                  DT::datatable(d), 
                  widths = 5)        
```

# 2. Programming Animated Statistical Graphics with R

## 2.1 Overview

When presenting a visually-driven data story, animated graphics often capture the audience’s attention and leave a stronger impression than static visuals. In this hands-on exercise, you will learn how to create animated data visualizations using the **gganimate** and **plotly** R packages. Additionally, you will practice how to (i) reshape data with the **tidyr** package and (ii) process, wrangle, and transform data using the **dplyr** package.

### 2.1.1 Basic concepts of animation

When creating animations, the plot does not actually move. Instead, many individual plots are built and then stitched together as movie frames, just like an old-school flip book or cartoon. Each frame is a different plot when conveying motion, which is built using some relevant subset of the aggregate data. The subset drives the flow of the animation when stitched back together.

### 2.1.2 Terminology

Before we dive into the steps for creating an animated statistical graph, it’s important to understand some of the key concepts and terminology related to this type of visualization.

1.  **Frame**: In an animated line graph, each frame represents a different point in time or a different category. When the frame changes, the data points on the graph are updated to reflect the new data.

2.  **Animation Attributes**: The animation attributes are the settings that control how the animation behaves. For example, you can specify the duration of each frame, the easing function used to transition between frames, and whether to start the animation from the current frame or from the beginning.

## 2.2 Getting Started

### 2.2.1 Loading the R packages

First, write a code chunk to check, install and load the following R packages:

-   [**plotly**](https://plotly.com/r/), R library for plotting interactive statistical graphs.

-   [**gganimate**](https://gganimate.com/), an ggplot extension for creating animated statistical graphs.

-   [**gifski**](https://cran.r-project.org/web/packages/gifski/index.html) converts video frames to GIF animations using pngquant’s fancy features for efficient cross-frame palettes and temporal dithering. It produces animated GIFs that use thousands of colors per frame.

-   [**gapminder**](https://cran.r-project.org/web/packages/gapminder/index.html): An excerpt of the data available at Gapminder.org. We just want to use its *country_colors* scheme.

-   [**tidyverse**](https://www.tidyverse.org/), a family of modern R packages specially designed to support data science, analysis and communication task including creating static statistical graphs.

```{r}
pacman::p_load(readxl, gifski, gapminder,
               plotly, gganimate, tidyverse)
```

### 2.2.2 Importing the data

In this hands-on exercise, the *Data* worksheet from *GlobalPopulation* Excel workbook will be used.

Write a code chunk to import Data worksheet from GlobalPopulation Excel workbook by using appropriate R package from tidyverse family.

```{r}
col <- c("Country", "Continent")
globalPop <- read_xls("data/GlobalPopulation.xls",
                      sheet="Data") %>%
  mutate_each_(funs(factor(.)), col) %>%
  mutate(Year = as.integer(Year))
```

Unfortunately, `mutate_each_()` was deprecated in dplyr 0.7.0. and `funs()` was deprecated in dplyr 0.8.0. In view of this, we will re-write the code by using [`mutate_at()`](https://r4va.netlify.app/chap04) as shown in the code chunk below.

```{r}
col <- c("Country", "Continent")
globalPop <- read_xls("data/GlobalPopulation.xls",
                      sheet="Data") %>%
  mutate_at(col, as.factor) %>%
  mutate(Year = as.integer(Year))
```

Instead of using `mutate_at()`, [`across()`](https://dplyr.tidyverse.org/reference/across.html) can be used to derive the same outputs.

```{r}
col <- c("Country", "Continent")
globalPop <- read_xls("data/GlobalPopulation.xls",
                      sheet="Data") %>%
  mutate(across(col, as.factor)) %>%
  mutate(Year = as.integer(Year))
```

## 2.3 Animated Data Visualization: gganimate methods

[**gganimate**](https://gganimate.com/) extends the grammar of graphics as implemented by ggplot2 to include the description of animation. It does this by providing a range of new grammar classes that can be added to the plot object in order to customise how it should change with time.

-   `transition_*()` defines how the data should be spread out and how it relates to itself across time.

-   `view_*()` defines how the positional scales should change along the animation.

-   `shadow_*()` defines how data from other points in time should be presented in the given point in time.

-   `enter_*()/exit_*()` defines how new data should appear and how old data should disappear during the course of the animation.

-   `ease_aes()` defines how different aesthetics should be eased during transitions.

### 2.3.1 Building a static population bubble plot

In the code chunk below, the basic ggplot2 functions are used to create a static bubble plot.

```{r}
ggplot(globalPop, aes(x = Old, y = Young, 
                      size = Population, 
                      colour = Country)) +
  geom_point(alpha = 0.7, 
             show.legend = FALSE) +
  scale_colour_manual(values = country_colors) +
  scale_size(range = c(2, 12)) +
  labs(title = 'Year: {frame_time}', 
       x = '% Aged', 
       y = '% Young') 
```

### 2.3.2 Building the animated bubble plot

In the code chunk below,

-   [`transition_time()`](https://gganimate.com/reference/transition_time.html) of **gganimate** is used to create transition through distinct states in time (i.e. Year).

-   `ease_aes()` is used to control easing of aesthetics. The default is `linear`. Other methods are: quadratic, cubic, quartic, quintic, sine, circular, exponential, elastic, back, and bounce.

```{r}
ggplot(globalPop, aes(x = Old, y = Young, 
                      size = Population, 
                      colour = Country)) +
  geom_point(alpha = 0.7, 
             show.legend = FALSE) +
  scale_colour_manual(values = country_colors) +
  scale_size(range = c(2, 12)) +
  labs(title = 'Year: {frame_time}', 
       x = '% Aged', 
       y = '% Young')         
```

## 2.4 Animated Data Visualization: plotly

In **Plotly R** package, both `ggplotly()` and `plot_ly()` support key frame animations through the `frame` argument/aesthetic. They also support an `ids` argument/aesthetic to ensure smooth transitions between objects with the same id (which helps facilitate object constancy).

### 2.4.1 Building an animated bubble plot: ggplotly() method

In this sub-section, we learn how to create an animated bubble plot by using `ggplotly()` method.

Notice that although `show.legend = FALSE` argument was used, the legend still appears on the plot. To overcome this problem, `theme(legend.position='none')` should be used as shown in the plot and code chunk below.

```{r}
gg <- ggplot(globalPop, 
       aes(x = Old, 
           y = Young, 
           size = Population, 
           colour = Country)) +
  geom_point(aes(size = Population,
                 frame = Year),
             alpha = 0.7, 
             show.legend = FALSE) +
  scale_colour_manual(values = country_colors) +
  scale_size(range = c(2, 12)) +
  labs(x = '% Aged', 
       y = '% Young')

ggplotly(gg)         
```

### 2.4.2 Building an animated bubble plot: plot_ly() method

In this sub-section, you will learn how to create an animated bubble plot by using `plot_ly()` method.

```{r}
bp <- globalPop %>%
  plot_ly(x = ~Old, 
          y = ~Young, 
          size = ~Population, 
          color = ~Continent,
          sizes = c(2, 100),
          frame = ~Year, 
          text = ~Country, 
          hoverinfo = "text",
          type = 'scatter',
          mode = 'markers'
          ) %>%
  layout(showlegend = FALSE)
bp            
```
